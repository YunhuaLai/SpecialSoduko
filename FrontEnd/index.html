<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Chessboard</title>
    <link rel="stylesheet" type="text/css" href="styles.css">
    <style>
        table {
            border-collapse: collapse;
            margin: 20px auto;
        }
        td, th {
            border: 1px solid black;
            width: 50px;
            height: 50px;
            text-align: center;
            vertical-align: middle;
        }
        .true { background-color: lightgreen; }
        .false { background-color: lightcoral; }
        .undefined { background-color: lightgray; }
    </style>
</head>
<body>
    <table id="chessboard"></table>

    <script>
        const API_BASE_URL = 'http://127.0.0.1:5000';

        // Fetch chessboard data from the backend
        async function loadBoard() {
            const response = await fetch(`${API_BASE_URL}/get_board`);
            const data = await response.json();

            const table = document.getElementById('chessboard');
            table.innerHTML = ''; // Clear existing board

            // Add column conditions
            let headerRow = document.createElement('tr');
            headerRow.innerHTML = '<th></th>'; // Empty top-left corner for alignment
            data.col_conditions.forEach((col, index) => {
                let th = document.createElement('th');
                th.classList.add('col-condition'); // Add col-condition class
                th.setAttribute('data-index', index); // Add data-index for identification

                // Create individual spans for each segment of the column condition
                th.innerHTML = col.map(segment => `<span class="condition-segment">${segment}</span>`).join(', ');
                headerRow.appendChild(th); // Append to the header row
            });
            table.appendChild(headerRow);

            // Add rows with row conditions and cells
            data.board.forEach((row, i) => {
                let rowElement = document.createElement('tr');

                // Add row condition
                let rowHeader = document.createElement('th');
                rowHeader.classList.add('row-condition'); // Add row-condition class
                rowHeader.setAttribute('data-index', i); // Add data-index for identification

                // Create individual spans for each segment of the row condition
                rowHeader.innerHTML = data.row_conditions[i].map(segment => `<span class="condition-segment">${segment}</span>`).join(', ');
                rowElement.appendChild(rowHeader);

                // Add cells
                row.forEach((cell, j) => {
                    let cellElement = document.createElement('td');
                    cellElement.className = cell === true ? 'true' : cell === false ? 'false' : 'undefined';
                    cellElement.onclick = () => updateCell(i, j, cellElement);
                    rowElement.appendChild(cellElement);
                });

                table.appendChild(rowElement);
            });
        }


        async function updateCell(x, y, cellElement) {
            const response = await fetch(`${API_BASE_URL}/update_cell`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ x, y })
            });
            const data = await response.json();

            console.log("Backend response:", data); // Check row_violations and column_violations

            const newValue = data.new_value;
            cellElement.className = newValue === true ? 'true' : newValue === false ? 'false' : 'undefined';

            // Highlight row and column violations
            highlightViolations(x, 'row', data.row_violations);
            highlightViolations(y, 'col', data.column_violations);
        }

        function highlightViolations(index, type, violations) {
            console.log(`Highlighting violations for ${type} at index ${index}:`, violations);

            // Select the main condition element (the <th>)
            const conditionElement = document.querySelector(
                `.${type}-condition[data-index="${index}"]`
            );
            console.log(`Condition element for ${type} at index ${index}:`, conditionElement);

            if (!conditionElement) {
                console.error(`No ${type}-condition element found for index ${index}`);
                return;
            }

            // Select individual condition segments (<span>)
            const segments = conditionElement.querySelectorAll('.condition-segment');
            console.log(`Segments found for ${type} index ${index}:`, segments);
            console.log(`Segments length: ${segments.length}, Violations length: ${violations.length}`);

            // Apply or remove the violation class for each segment
            segments.forEach((el, i) => {
                if (i < violations.length && violations[i]) {
                    el.classList.add('violation'); // Highlight the segment with a violation
                    console.log(`Violation added to ${type} segment ${i}:`, el);
                } else {
                    el.classList.remove('violation'); // Remove highlight if no violation
                    console.log(`Violation removed from ${type} segment ${i}:`, el);
                }
            });
        }


        // Call this function when rendering row and column conditions
        function renderConditions(conditions, type) {
            return conditions.map((condition, index) => `
                <div class="${type}-condition" data-index="${index}">
                    ${condition.map(num => `<span class="condition-segment">${num}</span>`).join(', ')}
                </div>
            `).join('');
        }

        // Load the board on page load
        window.onload = loadBoard;
    </script>
</body>
</html>
